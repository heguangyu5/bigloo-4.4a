<!-- 95% W3C COMPLIANT, 95% CSS FREE, RAW HTML -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1">
<title>Bigloo</title>
 <style type="text/css">
  <!--
  pre { font-family: monospace }
  tt { font-family: monospace }
  code { font-family: monospace }
  p.flushright { text-align: right }
  p.flushleft { text-align: left }
  span.sc { font-variant: small-caps }
  span.sf { font-family: sans-serif }
  span.skribetitle { font-family: sans-serif; font-weight: bolder; font-size: x-large; }
  span.refscreen { }
  span.refprint { display: none; }
  -->
 </style>
</head>

<body class="chapter" bgcolor="#ffffff">
<table width="100%" class="skribetitle" cellspacing="0" cellpadding="0"><tbody>
<tr><td align="center" bgcolor="#8381de"><div class="skribetitle"><strong><big><big><big>3. Bigloo<br/>A practical Scheme compiler (4.4a)<br/>User manual for version 4.4a<br/>November 2020 -- Modules</big></big></big></strong></div><center>
</center>
</td></tr></tbody></table>
<table cellpadding="3" cellspacing="0" width="100%" class="skribe-margins"><tr>
<td align="left" valign="top" class="skribe-left-margin" width="20%" bgcolor="#dedeff"><div class="skribe-left-margin">
<br/><center id='center31081'
><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th id="tc31071" align="center" colspan="1"><font color="#ffffff"><strong id='bold31069'
>main page</strong></font></th></tr>
<tr bgcolor="#ffffff"><td id="tc31078" align="center" colspan="1"><table width="100%" border="0" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc31074" align="left" valign="top" colspan="1"><strong id='bold31073'
>top:</strong></td><td id="tc31075" align="right" valign="top" colspan="1"><a href="bigloo.html#Bigloo-A-practical-Scheme-compiler-(-4.4a-)-User-manual-for-version-4.4a-November-2020" class="inbound">Bigloo<br/>A practical Scheme compiler (4.4a)<br/>User manual for version 4.4a<br/>November 2020</a></td></tr>
</tbody></table>
</td></tr>
</tbody></table>
</center>
<br/><br/><center id='center31091'
><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th id="tc31085" align="center" colspan="1"><font color="#ffffff"><strong id='bold31083'
>Modules</strong></font></th></tr>
<tr bgcolor="#ffffff"><td id="tc31088" align="center" colspan="1"><table cellspacing="1" cellpadding="1" width="100%" class="toc">
<tbody>
 <tr><td valign="top" align="left">3.1</td><td colspan="4" width="100%"><a href="bigloo-4.html#Program-Structure">Program Structure</a></td></tr>
 <tr><td valign="top" align="left">3.2</td><td colspan="4" width="100%"><a href="bigloo-4.html#Module-declaration">Module declaration</a></td></tr>
 <tr><td valign="top" align="left">3.3</td><td colspan="4" width="100%"><a href="bigloo-4.html#Module-initialization">Module initialization</a></td></tr>
 <tr><td valign="top" align="left">3.4</td><td colspan="4" width="100%"><a href="bigloo-4.html#Qualified-notation">Qualified notation</a></td></tr>
 <tr><td valign="top" align="left">3.5</td><td colspan="4" width="100%"><a href="bigloo-4.html#Inline-procedures">Inline procedures</a></td></tr>
 <tr><td valign="top" align="left">3.6</td><td colspan="4" width="100%"><a href="bigloo-4.html#Module-access-file">Module access file</a></td></tr>
 <tr><td valign="top" align="left">3.7</td><td colspan="4" width="100%"><a href="bigloo-4.html#Reading-path">Reading path</a></td></tr>
</tbody>
</table>
</td></tr>
</tbody></table>
</center>
<br/><br/><center id='center31101'
><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th id="tc31095" align="center" colspan="1"><font color="#ffffff"><strong id='bold31093'
>Chapters</strong></font></th></tr>
<tr bgcolor="#ffffff"><td id="tc31098" align="center" colspan="1"><table cellspacing="1" cellpadding="1" width="100%" class="toc">
<tbody>
 <tr><td valign="top" align="left"></td><td colspan="4" width="100%"><a href="bigloo-1.html#Acknowledgements">Acknowledgements</a></td></tr>
 <tr><td valign="top" align="left">1</td><td colspan="4" width="100%"><a href="bigloo-2.html#Table-of-contents">Table of contents</a></td></tr>
 <tr><td valign="top" align="left">2</td><td colspan="4" width="100%"><a href="bigloo-3.html#Overview-of-Bigloo">Overview of Bigloo</a></td></tr>
 <tr><td valign="top" align="left">3</td><td colspan="4" width="100%"><a href="bigloo-4.html#Modules">Modules</a></td></tr>
 <tr><td valign="top" align="left">4</td><td colspan="4" width="100%"><a href="bigloo-5.html#Core-Language">Core Language</a></td></tr>
 <tr><td valign="top" align="left">5</td><td colspan="4" width="100%"><a href="bigloo-6.html#DSSSL-support">DSSSL support</a></td></tr>
 <tr><td valign="top" align="left">6</td><td colspan="4" width="100%"><a href="bigloo-7.html#Standard-Library">Standard Library</a></td></tr>
 <tr><td valign="top" align="left">7</td><td colspan="4" width="100%"><a href="bigloo-8.html#Pattern-Matching">Pattern Matching</a></td></tr>
 <tr><td valign="top" align="left">8</td><td colspan="4" width="100%"><a href="bigloo-9.html#Fast-search">Fast search</a></td></tr>
 <tr><td valign="top" align="left">9</td><td colspan="4" width="100%"><a href="bigloo-10.html#Structures-and-Records">Structures and Records</a></td></tr>
 <tr><td valign="top" align="left">10</td><td colspan="4" width="100%"><a href="bigloo-11.html#Object-System">Object System</a></td></tr>
 <tr><td valign="top" align="left">11</td><td colspan="4" width="100%"><a href="bigloo-12.html#Regular-parsing">Regular parsing</a></td></tr>
 <tr><td valign="top" align="left">12</td><td colspan="4" width="100%"><a href="bigloo-13.html#Lalr(1)-parsing">Lalr(1) parsing</a></td></tr>
 <tr><td valign="top" align="left">13</td><td colspan="4" width="100%"><a href="bigloo-14.html#Posix-Regular-Expressions">Posix Regular Expressions</a></td></tr>
 <tr><td valign="top" align="left">14</td><td colspan="4" width="100%"><a href="bigloo-15.html#Command-Line-Parsing">Command Line Parsing</a></td></tr>
 <tr><td valign="top" align="left">15</td><td colspan="4" width="100%"><a href="bigloo-16.html#Cryptography">Cryptography</a></td></tr>
 <tr><td valign="top" align="left">16</td><td colspan="4" width="100%"><a href="bigloo-17.html#Errors-Assertions-and-Traces">Errors, Assertions, and Traces</a></td></tr>
 <tr><td valign="top" align="left">17</td><td colspan="4" width="100%"><a href="bigloo-18.html#Threads">Threads</a></td></tr>
 <tr><td valign="top" align="left">18</td><td colspan="4" width="100%"><a href="bigloo-19.html#Database">Database</a></td></tr>
 <tr><td valign="top" align="left">19</td><td colspan="4" width="100%"><a href="bigloo-20.html#Multimedia">Multimedia</a></td></tr>
 <tr><td valign="top" align="left">20</td><td colspan="4" width="100%"><a href="bigloo-21.html#Mail">Mail</a></td></tr>
 <tr><td valign="top" align="left">21</td><td colspan="4" width="100%"><a href="bigloo-22.html#Text">Text</a></td></tr>
 <tr><td valign="top" align="left">22</td><td colspan="4" width="100%"><a href="bigloo-23.html#CSV">CSV</a></td></tr>
 <tr><td valign="top" align="left">23</td><td colspan="4" width="100%"><a href="bigloo-24.html#Eval-and-code-interpretation">Eval and code interpretation</a></td></tr>
 <tr><td valign="top" align="left">24</td><td colspan="4" width="100%"><a href="bigloo-25.html#Macro-expansion">Macro expansion</a></td></tr>
 <tr><td valign="top" align="left">25</td><td colspan="4" width="100%"><a href="bigloo-26.html#Parameters">Parameters</a></td></tr>
 <tr><td valign="top" align="left">26</td><td colspan="4" width="100%"><a href="bigloo-27.html#Explicit-typing">Explicit typing</a></td></tr>
 <tr><td valign="top" align="left">27</td><td colspan="4" width="100%"><a href="bigloo-28.html#The-C-interface">The C interface</a></td></tr>
 <tr><td valign="top" align="left">28</td><td colspan="4" width="100%"><a href="bigloo-29.html#The-Java-interface">The Java interface</a></td></tr>
 <tr><td valign="top" align="left">29</td><td colspan="4" width="100%"><a href="bigloo-30.html#Bigloo-Libraries">Bigloo Libraries</a></td></tr>
 <tr><td valign="top" align="left">30</td><td colspan="4" width="100%"><a href="bigloo-31.html#Extending-the-Runtime-System">Extending the Runtime System</a></td></tr>
 <tr><td valign="top" align="left">31</td><td colspan="4" width="100%"><a href="bigloo-32.html#SRFIs">SRFIs</a></td></tr>
 <tr><td valign="top" align="left">32</td><td colspan="4" width="100%"><a href="bigloo-33.html#Compiler-description">Compiler description</a></td></tr>
 <tr><td valign="top" align="left">33</td><td colspan="4" width="100%"><a href="bigloo-34.html#Cross-Compilation">Cross Compilation</a></td></tr>
 <tr><td valign="top" align="left">34</td><td colspan="4" width="100%"><a href="bigloo-35.html#User-Extensions">User Extensions</a></td></tr>
 <tr><td valign="top" align="left">35</td><td colspan="4" width="100%"><a href="bigloo-36.html#Bigloo-Development-Environment">Bigloo Development Environment</a></td></tr>
 <tr><td valign="top" align="left">36</td><td colspan="4" width="100%"><a href="bigloo-37.html#Global-Index">Global Index</a></td></tr>
 <tr><td valign="top" align="left">37</td><td colspan="4" width="100%"><a href="bigloo-38.html#Library-Index">Library Index</a></td></tr>
 <tr><td valign="top" align="left"></td><td colspan="4" width="100%"><a href="bigloo-39.html#Bibliography">Bibliography</a></td></tr>
</tbody>
</table>
</td></tr>
</tbody></table>
</center>
</div></td>
<td align="left" valign="top" class="skribe-body"><div class="skribe-body">
<a name="Modules" class="mark"></a><a name="g1118" class="mark"></a>
A modules is a compiler and interpreter entity. Modules have been
first designed for the compiler that compiles modules and then, links
them against libraries in order to produce executables. A module may
be split into several files but a file cannot contain more than
<em id='emph1120'
>one</em> module. A module is made of a module clause that is a list
for which the <code id='code1121'
>car</code> is the symbol <code id='code1122'
>module</code> and followed by
any Bigloo expression (that is definitions or expressions). The module
clause names the module and defines the scope of the definitions. At
last, the module clause is also the place where foreign bindings are
defined and where classes are defined. Recent versions of Bigloo (since 2.7b)
fully supports modules from the interpreter.<br/><br/>
<!-- Program Structure -->
<a name="Program-Structure"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.1 Program Structure</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Program-Structure" class="mark"></a><a name="g1124" class="mark"></a>
A Bigloo program is composed of one or more Bigloo modules where a module is
defined by the following grammar:<br/><br/><center id='center1129'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ccccff"><pre class="prog" id='prog1127'
>&lt;module&gt;             ==&gt; &lt;module-declaration&gt; &lt;module-body&gt;
&lt;module-declaration&gt; ==&gt; the module declaration
&lt;module-body&gt;        ==&gt; the module body
</pre>
</td></tr>
</tbody></table></center>

A module is not related to a specific file and can be spread over
several files if that is convenient. In particular, there is no
relationship between module names and file names. The module declaration
(see <a href="bigloo-4.html#Module-Declaration" class="inbound">Module Declaration</a>) must be the first expression in the first
of the files containing the module; other expressions form the body of
the module. The module body (see <a href="bigloo-5.html#Core-Language" class="inbound">Core Language</a>) contains global 
variables, function definitions and <em id='emph1130'
>top level</em> expressions
(see <a href="bigloo-5.html#Expressions" class="inbound">Expressions</a>).<br/><br/></div><br>
<!-- Module declaration -->
<a name="Module-declaration"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.2 Module declaration</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Module-Declaration" class="mark"></a><a name="g1132" class="mark"></a>
The module declaration form is<br/><br/><table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1136" class="mark"></a><a name="module" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1140" align="left" colspan="1"><strong id='bold1138'
>module</strong><em id='it1139'
> name clause ...</em></td><td id="tc1141" align="right" colspan="1">bigloo syntax</td></tr>
</tbody></table>

This form defines a module and must be the first in the file.  The
argument <code id='code1145'
><em id='it1144'
>name</em></code> is a symbol naming the module. If the same
module name is used more than once, Bigloo signals an error. The
runtime library is composed of modules that are read when a user module
is compiled and hence, if a user module has the same name as one of the
library modules, an error is signaled.<br/><br/>A simple module can be:<br/><br/><center id='center1154'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1152'
>(<font color="#1919af"><strong id='bold31102'
>module</strong></font> <font color="#1919af"><strong id='bold31104'
>foo</strong></font>)<br/><br/>(display <font color="red">&quot;this is a module&quot;</font>)
</pre>
</td></tr>
</tbody></table></center>

The first line here is the complete module definition, the last line is
the complete module body and together they form a complete Bigloo program. If
these lines were stored in file <code id='code1155'
>zz.scm</code>, invoking <samp id='samp1156'
>bigloo zz.scm</samp>
would create the executable <code id='code1157'
>a.out</code> which, when obeyed, would
display <samp id='samp1158'
>this is a module</samp> on the terminal.<br/><br/><em id='emph1160'
>Note</em>:
Some special identifiers are reserved and can't be used to name modules.
If such an identifier is used, the compiler will produce the message:<br/><br/><center id='center1169'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1167'
>#(<font color="#1919af"><strong id='bold31107'
>module</strong></font> <font color="#1919af"><strong id='bold31109'
>t</strong></font>
#^
# *** ERROR<strong id='bold31111'
>:bigloo</strong><strong id='bold31113'
>:TOP-LEVEL</strong><strong id='bold31115'
>:Parse</strong> error
# Illegal module name -- (MODULE eval ...
</pre>
</td></tr>
</tbody></table></center>

The list of reserved identifiers may be enlarged for next release. For 
the current release that list is made of: <code id='code1170'
>eval</code>, <code id='code1171'
>foreign</code> and 
<code id='code1172'
>t</code>.
</td></tr>
</tbody></table><br/>
Module <code id='code1176'
><em id='it1175'
>clause</em></code>s can be:<br/><br/><table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1179" class="mark"></a><a name="main" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1183" align="left" colspan="1"><strong id='bold1181'
>main</strong><em id='it1182'
> name</em></td><td id="tc1184" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

This clause defines the entry point for a stand alone application to be
procedure <code id='code1188'
><em id='it1187'
>name</em></code> of arity one. Bigloo invokes this procedure at the
beginning of execution providing the list, composed of the shell command
line arguments, as its single argument.<br/><br/><center id='center1196'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1194'
>(<font color="#1919af"><strong id='bold31117'
>module</strong></font> <font color="#1919af"><strong id='bold31119'
>foo</strong></font>
   (main start))<br/><br/>(<font color="#6959cf"><strong id='bold31121'
>define</strong></font> (<font color="#6959cf"><strong id='bold31123'
>start</strong></font> argv)
   (display argv)
   (newline))
</pre>
</td></tr>
</tbody></table></center>

Then if this program is compiled into <code id='code1197'
>foo</code> and invoked using the
command <samp id='samp1198'
>foo -t bar</samp>, the list which is the argument for the main 
procedure <code id='code1199'
>start</code> would be <code id='code1200'
>(&quot;foo&quot; &quot;-t&quot; &quot;bar&quot;)</code>. <br/><br/>The special form <code id='code1202'
>args-parse</code> helps main function argument parsing 
(see <a href="bigloo-15.html#Command-Line-Parsing" class="inbound">Command Line Parsing</a>).
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1206" class="mark"></a><a name="include" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1210" align="left" colspan="1"><strong id='bold1208'
>include</strong><em id='it1209'
> file-name ...</em></td><td id="tc1211" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>
<a name="g1214" class="mark"></a>
This is a list of <code id='code1217'
><em id='it1216'
>file-name</em></code>s to be included in the source file. Include
files are not modules and may have a special syntax. Thus, besides containing
Bigloo expressions, they can contain import and include clauses, which must
be written in a single list whose first element is the keyword 
<code id='code1218'
>directives</code>. Includes files can be used to include implementation-neutral
Scheme expressions and definitions in a Bigloo module. Here is an example of 
an include file.<br/><br/><center id='center1223'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1221'
><font color="#ffa600"><em id='it31125'
>;; </em></font>`foo.sch'
(<font color="#6959cf"><strong id='bold31127'
>define-struct</strong></font> <font color="#6959cf"><strong id='bold31129'
>point</strong></font> x y)
</pre>
</td></tr>
</tbody></table></center>

and the module that includes the `foo.sch' file:<br/><br/><center id='center1231'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1229'
><font color="#ffa600"><em id='it31131'
>;; </em></font>`foo.scm'
(<font color="#1919af"><strong id='bold31133'
>module</strong></font> <font color="#1919af"><strong id='bold31135'
>foo</strong></font>
   (include <font color="red">&quot;foo.sch&quot;</font>))<br/><br/>(print (point 1 2))
</pre>
</td></tr>
</tbody></table></center>

Include files, may contain module information. This is the role of the
include <code id='code1232'
>directives</code> clause here illustrated with the `bar.sch'
example:<br/><br/><center id='center1241'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1239'
><font color="#ffa600"><em id='it31138'
>;; </em></font>`bar.sch'
<font color="#ffa600"><em id='it31140'
>;; the directives</em></font>
(directives (include <font color="red">&quot;foobar.sch&quot;</font>)
            (<font color="#1919af"><strong id='bold31143'
>import</strong></font>  <font color="#1919af"><strong id='bold31145'
>hux</strong></font>))<br/><br/><font color="#ffa600"><em id='it31147'
>;; expressions</em></font>
(<font color="#6959cf"><strong id='bold31149'
>define</strong></font> (<font color="#6959cf"><strong id='bold31151'
>gee</strong></font> x) (print x))
</pre>
</td></tr>
</tbody></table></center>
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1245" class="mark"></a><a name="import" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1249" align="left" colspan="1"><strong id='bold1247'
>import</strong><em id='it1248'
> import ...</em></td><td id="tc1250" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

An <code id='code1254'
><em id='it1253'
>import</em></code> is a list of the form:<br/><br/><center id='center1258'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ccccff"><pre class="prog" id='prog1256'
>&lt;import&gt;      ==&gt; &lt;iclause&gt; ...
&lt;iclause&gt;     ==&gt; (&lt;bind-name&gt; ... &lt;bind-name&gt; &lt;module-name&gt; &lt;file-name&gt; ...)
                | (&lt;bind-name&gt; ... &lt;bind-name&gt; &lt;module-name&gt;)
                | &lt;module-name&gt;
                | (&lt;module-name&gt; &lt;file-name&gt; ...)
&lt;bind-name&gt;   ==&gt; &lt;r5rs-ident&gt;
                | &lt;alias-name&gt;
&lt;alias-name&gt;  ==&gt; (&lt;r5rs-ident&gt; &lt;r5rs-ident&gt;)
&lt;module-name&gt; ==&gt; &lt;r5rs-ident&gt;
&lt;file-name&gt;   ==&gt; &lt;string&gt;
</pre>
</td></tr>
</tbody></table></center>

The first alternative in <code id='code1260'
><em id='it1259'
>iclause</em></code> imports the variable named 
<code id='code1262'
><em id='it1261'
>bind-name</em></code> which is defined in the module <code id='code1264'
><em id='it1263'
>module-name</em></code>, 
located in the files <code id='code1266'
><em id='it1265'
>file-name</em></code> .... The second does the same 
but without specifying the name of the file where the module is located.  
The third and the fourth form import all the exported variables of the module
<code id='code1268'
><em id='it1267'
>module-name</em></code>.<br/><br/><em id='emph1270'
>Note</em>: The need for specifying in which files modules are located comes
from the fact that there is no automatic mapping between module names
and files names. Such a mapping can be defined in a ``module access file''
(see <a href="bigloo-4.html#Module-Access-File" class="inbound">Module Access File</a>) or in the import clause itself, as
in the first and fourth alternatives in <code id='code1272'
><em id='it1271'
>iclause</em></code> above.<br/><br/>Here is an example of an import clause:<br/><br/><center id='center1294'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1292'
>(<font color="#1919af"><strong id='bold31153'
>module</strong></font> <font color="#1919af"><strong id='bold31155'
>foo</strong></font>
<font color="#1919af"><strong id='bold31157'
>   </strong></font>(<font color="#1919af"><strong id='bold31159'
>import</strong></font><font color="#1919af"><strong id='bold31161'
> </strong></font>
      <font color="#ffa600"><em id='it31163'
>;; import all </em></font><code id='code1275'
>bar</code> exported bindings:
      bar
      <font color="#ffa600"><em id='it31165'
>;; import the </em></font><code id='code1276'
>hux</code> binding exported by
      <font color="#ffa600"><em id='it31167'
>;; the module </em></font><code id='code1277'
>hux</code>:
      (hux hux)       
      <font color="#ffa600"><em id='it31169'
>;; import the </em></font><code id='code1278'
>fun1</code>, <code id='code1279'
>fun2</code> and <code id='code1280'
>fun3</code> bindings exported by
      <font color="#ffa600"><em id='it31171'
>;; the module </em></font><code id='code1281'
>mod</code>:
      (fun1 fun2 fun3 mod)       
      <font color="#ffa600"><em id='it31173'
>;; import the </em></font><code id='code1282'
>fun4</code> bindings that will be known in this module
      <font color="#ffa600"><em id='it31175'
>;; under the alias name </em></font><code id='code1283'
>f</code>
      ((f fun4) mod)
      <font color="#ffa600"><em id='it31177'
>;; import all </em></font><code id='code1284'
>gee</code> bindings. the <code id='code1285'
>gee</code> module
      <font color="#ffa600"><em id='it31179'
>;; is located in a file called </em></font>`gee.scm':
      (gee <font color="red">&quot;gee.scm&quot;</font>)))
</pre>
</td></tr>
</tbody></table></center>

</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1298" class="mark"></a><a name="use" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1302" align="left" colspan="1"><strong id='bold1300'
>use</strong><em id='it1301'
> use ...</em></td><td id="tc1303" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

<code id='code1306'
>use</code> has the same meaning as <code id='code1307'
>import</code> except that modules
which are <em id='emph1308'
>used</em> are not initialized (see <a href="bigloo-4.html#Module-Initialization" class="inbound">Module Initialization</a>).
Used modules are read before imported modules.
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1312" class="mark"></a><a name="with" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1316" align="left" colspan="1"><strong id='bold1314'
>with</strong><em id='it1315'
> with ...</em></td><td id="tc1317" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

This clause specifies a list of modules which have to be
initialized at runtime and is used to force the initialization
of modules which are never imported but which are required by an 
application (see <a href="bigloo-28.html#Embedded-Bigloo-applications" class="inbound">Embedded Bigloo applications</a>).
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1323" class="mark"></a><a name="export" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1327" align="left" colspan="1"><strong id='bold1325'
>export</strong><em id='it1326'
> export ...</em></td><td id="tc1328" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

In order to make a module's global bindings available to other modules, they
have to be <em id='emph1331'
>exported</em>. Export clauses are in charge of this task and an
<code id='code1333'
><em id='it1332'
>export</em></code> is a list of the form:<br/><br/><center id='center1337'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ccccff"><pre class="prog" id='prog1335'
>&lt;export&gt;      ==&gt; &lt;eclause&gt; ...
&lt;eclause&gt;     ==&gt; &lt;varexport&gt;
                | &lt;funexport&gt;
                | &lt;macroexport&gt;
                | &lt;classexport&gt;
&lt;varexport&gt;   ==&gt; &lt;ident&gt;
&lt;funexport&gt;   ==&gt; | (&lt;ident&gt; &lt;ident&gt; ...)
                | (inline &lt;ident&gt; &lt;ident&gt; ...)
                | (generic &lt;ident&gt; &lt;ident&gt; &lt;ident&gt; ...)
&lt;classexport&gt; ==&gt; &lt;class&gt;
&lt;macroexport&gt; ==&gt; (macro &lt;ident&gt; &lt;ident&gt; ...)
                | (expander &lt;ident&gt;)
                | (syntax &lt;ident&gt;)
</pre>
</td></tr>
</tbody></table></center>

Note: Only bindings defined in module <code id='code1338'
>m</code> can be <em id='emph1339'
>exported</em> 
by <code id='code1340'
>m</code> (i.e. bindings <em id='emph1341'
>imported</em> by <code id='code1342'
>m</code> cannot be 
<em id='emph1343'
>exported</em> by <code id='code1344'
>m</code>).<br/><br/>The first form of <code id='code1347'
><em id='it1346'
>varexport</em></code> allows the variable <code id='code1349'
><em id='it1348'
>ident</em></code> be
exported.  Exported variables are mutable. That is, modules importing
a variable can change its value.<br/><br/>The form <code id='code1352'
><em id='it1351'
>funexport</em></code> exports functions. An exported function is
read-only. No module can modify its value. The prototype of exported
functions must be explicitly specified.<br/><br/>Type information, specified in any <code id='code1355'
><em id='it1354'
>ident</em></code> in an export clause, is
used by Bigloo. Where no type information is given, a default generic
type named <code id='code1356'
>obj</code> is used.<br/><br/>Note: The last formal argument of a multiple arity function can
not be typed because this argument is bound to be a <code id='code1358'
>pair</code>
or <code id='code1359'
>null</code>. This union cannot be denoted by any type.<br/><br/>Inline functions (see <a href="bigloo-4.html#Inline-Procedures" class="inbound">Inline Procedures</a>) prototypes are prefixed
by the <code id='code1361'
>inline</code> keyword. Pay attention that in order to export an
inline function, all the variables used in that function body must be
exported too.  It is an error to export a non-inline function using
the <code id='code1362'
>inline</code> keyword. Example:<br/><br/><center id='center1375'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1373'
>(<font color="#1919af"><strong id='bold31182'
>module</strong></font> <font color="#1919af"><strong id='bold31184'
>mod-exp</strong></font>
<font color="#1919af"><strong id='bold31186'
>   </strong></font>(<font color="#1919af"><strong id='bold31188'
>export</strong></font><font color="#1919af"><strong id='bold31190'
> </strong></font>
      <font color="#ffa600"><em id='it31192'
>;; export the </em></font><code id='code1364'
>bar</code> mutable variable
      bar
      <font color="#ffa600"><em id='it31194'
>;; export the </em></font><code id='code1365'
>hux</code> function. this
      <font color="#ffa600"><em id='it31196'
>;; function takes exactly two arguments</em></font>
      (hux x y)       
      <font color="#ffa600"><em id='it31198'
>;; export the inline function </em></font><code id='code1366'
>gee</code>
      <font color="#ffa600"><em id='it31200'
>;; that takes at least one argument.</em></font>
      (<strong id='bold31202'
>inline</strong> gee x . z)))
</pre>
</td></tr>
</tbody></table></center>

Generic functions (see <a href="bigloo-11.html#Generic-functions" class="inbound">Generic functions</a>) are exported by using
the <code id='code1376'
>generic</code> keyword.  Note that methods are not exported. Only
the generic function they are attached to are. It is an error to
export a non-generic function using the <code id='code1377'
>inline</code> keyword.
Example:<br/><br/><center id='center1392'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1390'
>(<font color="#1919af"><strong id='bold31203'
>module</strong></font> <font color="#1919af"><strong id='bold31205'
>mod-exp-object</strong></font>
<font color="#1919af"><strong id='bold31207'
>   </strong></font>(<font color="#1919af"><strong id='bold31209'
>export</strong></font><font color="#1919af"><strong id='bold31211'
> </strong></font>
      <font color="#ffa600"><em id='it31213'
>;; define tow classes an export them</em></font>
      (<strong id='bold31215'
>class</strong> point2d x y)
      (<strong id='bold31216'
>class</strong> point3d<font color="#00cf00"><strong id='bold31217'
>::point2d</strong></font> z)
      <font color="#ffa600"><em id='it31219'
>;; export a generic function</em></font>
      (<strong id='bold31221'
>generic</strong> show <font color="#00cf00"><strong id='bold31222'
>::point2d</strong></font> <font color="#00cf00"><strong id='bold31224'
>::output-port</strong></font>)))
</pre>
</td></tr>
</tbody></table></center>

It is an error to export an inline or a generic function without using
the proper keyword. <br/><br/>The last form <code id='code1395'
><em id='it1394'
>macroexport</em></code> enables macro and expanders to be
exported. The prototype of the macro should be specified on the export
clause. Example:<br/><br/><center id='center1412'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1410'
>(<font color="#1919af"><strong id='bold31226'
>module</strong></font> <font color="#1919af"><strong id='bold31228'
>mod-exp-macros</strong></font>
<font color="#1919af"><strong id='bold31230'
>   </strong></font>(<font color="#1919af"><strong id='bold31232'
>export</strong></font><font color="#1919af"><strong id='bold31234'
> </strong></font>
      <font color="#ffa600"><em id='it31236'
>;; exports the ``add'' macro</em></font>
      (macro add x y)
      <font color="#ffa600"><em id='it31238'
>;; exports the ``+'' expander</em></font>
      (expander +)))<br/><br/>(<font color="#6959cf"><strong id='bold31240'
>define-macro</strong></font> (<font color="#6959cf"><strong id='bold31242'
>add</strong></font> x y)
   (<strong id='bold31244'
>if</strong> (and (number? x) (number? y))
       (+ x y)
       `(+ ,x ,y)))<br/><br/>(<font color="#6959cf"><strong id='bold31245'
>define-expander</strong></font> <font color="#6959cf"><strong id='bold31247'
>+</strong></font>
   (<strong id='bold31249'
>lambda</strong> (x e)
      (<strong id='bold31250'
>match-case</strong> x
         ((+ ?n ?m) (+ n m))
         (else (map (<strong id='bold31251'
>lambda</strong> (z e) (e z e)) x)))))
</pre>
</td></tr>
</tbody></table></center>
<br/><br/></td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1417" class="mark"></a><a name="static" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1421" align="left" colspan="1"><strong id='bold1419'
>static</strong><em id='it1420'
> static ...</em></td><td id="tc1422" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

A <code id='code1425'
>static</code> clause has exactly the same syntax as an export
clause. However, bindings declared static are local to the module. Since
the default scope of all bindings is static, <code id='code1426'
>static</code> module clauses
are useful only for program documentation.<br/><br/></td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1431" class="mark"></a><a name="from" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1435" align="left" colspan="1"><strong id='bold1433'
>from</strong><em id='it1434'
> from ...</em></td><td id="tc1436" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

<code id='code1439'
>from</code> clauses have the syntax of <code id='code1440'
>import</code> 
clauses. The allow the re-exportation of imported bindings. That is, any 
module can export any bindings imported via a <code id='code1442'
><em id='it1441'
>from</em></code> clause.<br/><br/>As an example, suppose we have module <code id='code1444'
>bar</code>:<br/><br/><center id='center1455'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1453'
>(<font color="#1919af"><strong id='bold31252'
>module</strong></font> <font color="#1919af"><strong id='bold31254'
>bar</strong></font>
   (<font color="#1919af"><strong id='bold31256'
>export</strong></font> (<font color="#1919af"><strong id='bold31258'
>fun</strong></font>)))<br/><br/>(<font color="#6959cf"><strong id='bold31260'
>define</strong></font> (<font color="#6959cf"><strong id='bold31262'
>fun</strong></font>) <font color="red">&quot;bar&quot;</font>)
</pre>
</td></tr>
</tbody></table></center>

Now, suppose we have a module <code id='code1456'
>foo</code> that imports <code id='code1457'
>bar</code>, by the
means of a <code id='code1458'
>from</code> clause. Module <code id='code1459'
>foo</code> is able to re-export the
<code id='code1460'
>bar</code> binding of module <code id='code1461'
>bar</code>:<br/><br/><center id='center1468'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1466'
>(<font color="#1919af"><strong id='bold31265'
>module</strong></font> <font color="#1919af"><strong id='bold31267'
>foo</strong></font>
   (from (fun bar <font color="red">&quot;bar.scm&quot;</font>)))
</pre>
</td></tr>
</tbody></table></center>

A third module, let's name it <code id='code1469'
>gee</code>, importing module <code id='code1470'
>foo</code>, can see
the binding for function <code id='code1471'
>bar</code>:<br/><br/><center id='center1481'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1479'
>(<font color="#1919af"><strong id='bold31270'
>module</strong></font> <font color="#1919af"><strong id='bold31272'
>gee</strong></font>
   (<font color="#1919af"><strong id='bold31274'
>import</strong></font> (<font color="#1919af"><strong id='bold31276'
>foo</strong></font> <font color="red">&quot;foo.scm&quot;</font>)))<br/><br/>(print (fun))
</pre>
</td></tr>
</tbody></table></center>

This feature is very useful when compiling modules exporting functions
with type annotations. In particular, one may write:<br/><br/><center id='center1490'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1488'
>(<font color="#1919af"><strong id='bold31279'
>module</strong></font> <font color="#1919af"><strong id='bold31281'
>foo</strong></font>
  (<font color="#1919af"><strong id='bold31283'
>export</strong></font> (<strong id='bold31285'
>class</strong> <font color="#1919af"><strong id='bold31286'
>c1</strong></font> x)))
</pre>
</td></tr>
</tbody></table></center>

Then,
<center id='center1504'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1502'
>(<font color="#1919af"><strong id='bold31288'
>module</strong></font> <font color="#1919af"><strong id='bold31290'
>bar</strong></font>
  (<font color="#1919af"><strong id='bold31292'
>import</strong></font> <font color="#1919af"><strong id='bold31294'
>foo</strong></font>)
  (from foo)
  (<font color="#1919af"><strong id='bold31296'
>export</strong></font> (<font color="#1919af"><strong id='bold31298'
>fun</strong></font><font color="#00cf00"><strong id='bold31300'
>::c1</strong></font>)))<br/><br/>(<font color="#6959cf"><strong id='bold31302'
>define</strong></font> (<font color="#6959cf"><strong id='bold31304'
>fun</strong></font>)
   (<strong id='bold31306'
>instantiate</strong><font color="#00cf00"><strong id='bold31307'
>::c1</strong></font> (x 10)))
</pre>
</td></tr>
</tbody></table></center>

And,<br/><br/><center id='center1515'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1513'
>(<font color="#1919af"><strong id='bold31309'
>module</strong></font> <font color="#1919af"><strong id='bold31311'
>gee</strong></font>
   (<font color="#1919af"><strong id='bold31313'
>import</strong></font> <font color="#1919af"><strong id='bold31315'
>bar</strong></font>)
   (main main))<br/><br/>(<font color="#6959cf"><strong id='bold31317'
>define</strong></font> (<font color="#6959cf"><strong id='bold31319'
>main</strong></font> x)
   (<strong id='bold31321'
>let</strong> ((o (fun)))
      (print o)
      (print (c1? o))))
</pre>
</td></tr>
</tbody></table></center>

</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1519" class="mark"></a><a name="load" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1523" align="left" colspan="1"><strong id='bold1521'
>load</strong><em id='it1522'
> load ...</em></td><td id="tc1524" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

A <code id='code1528'
><em id='it1527'
>load</em></code> is a list of the form:<br/><br/><center id='center1532'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ccccff"><pre class="prog" id='prog1530'
>&lt;load&gt;    ==&gt; &lt;lclause&gt; ...
&lt;lclause&gt; ==&gt; (&lt;module-name&gt; &lt;file-name&gt;)
            | &lt;module-name&gt;
</pre>
</td></tr>
</tbody></table></center>

This clause forces Bigloo to load the module specified in the <code id='code1534'
><em id='it1533'
>lclause</em></code>
in the environment used by the macro expansion mechanism. This means that
the user's macros can use all the bindings of all the <code id='code1535'
>load</code>ed modules
but the <code id='code1536'
>load</code>ed bindings remains unknown to the compiler.<br/><br/>If the module <code id='code1538'
>foo</code> is defined by:<br/><br/><center id='center1548'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1546'
>(<font color="#1919af"><strong id='bold31322'
>module</strong></font> <font color="#1919af"><strong id='bold31324'
>foo</strong></font>
   (<font color="#1919af"><strong id='bold31326'
>export</strong></font> (<font color="#1919af"><strong id='bold31328'
>foo</strong></font> x)))<br/><br/>(<font color="#6959cf"><strong id='bold31330'
>define</strong></font> (<font color="#6959cf"><strong id='bold31332'
>foo</strong></font> x)
   `(cons ,x ,x))
</pre>
</td></tr>
</tbody></table></center>

then,<br/><br/><center id='center1558'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1556'
>(<font color="#1919af"><strong id='bold31334'
>module</strong></font> <font color="#1919af"><strong id='bold31336'
>gee</strong></font>
   (load (foo <font color="red">&quot;foo.scm&quot;</font>)))<br/><br/>(<font color="#6959cf"><strong id='bold31339'
>define-macro</strong></font> (<font color="#6959cf"><strong id='bold31341'
>gee</strong></font> x)
   `(cons ,(-fx x 1) ,(foo x)))<br/><br/>(gee 5)   ==&gt; (cons 4 (cons 5 5))
          =&gt; (4 5 . 5)
</pre>
</td></tr>
</tbody></table></center>
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1562" class="mark"></a><a name="eval" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1566" align="left" colspan="1"><strong id='bold1564'
>eval</strong><em id='it1565'
> eval...</em></td><td id="tc1567" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

This form allows interactions between compiled code and interpreted
code. (See the Section <a href="bigloo-24.html#Eval" class="inbound">Eval command line options</a> for a
presentation of compilation flags that enable compilation tuning for
<code id='code1570'
>eval</code>.)  Each <code id='code1572'
><em id='it1571'
>eval</em></code> has the following syntax:<br/><br/><center id='center1576'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ccccff"><pre class="prog" id='prog1574'
>&lt;eval&gt; ==&gt; (export-all)
         | (export-module)
         | (export-exports)
         | (export &lt;bind-name&gt;)
         | (export (&#x40; &lt;bind-name&gt; &lt;module-name&gt;))
         | (import &lt;bind-name&gt;)
         | (class &lt;bind-name&gt;)
         | (library lib1 ...)
</pre>
</td></tr>
</tbody></table></center>
<a name="g1577" class="mark"></a><a name="g1579" class="mark"></a><a name="g1581" class="mark"></a><a name="g1583" class="mark"></a>
The first clause, <code id='code1585'
>(export-all)</code>, exports all the variables bound
in the module (i.e., the variables defined in the module and the
imported variables).  The second clause, <code id='code1586'
>(export-module)</code>, exports
the module to eval to so that it can be imported by other evaluated
modules; the third exports all the exports (i.e. the ones present
inside an <code id='code1587'
>export</code> clause) variables to the interpreter; the fourth
and fifth clause each export one variable to the interpreter. The last
clause imports a variable from the interpreter and all such imported
variables are immutable (i.e. they cannot be the first argument of a
<code id='code1588'
>set!</code>  expression with the compiled code). Variables that are
exported to the evaluators <em id='emph1589'
>must</em> be exported.  If a variable is
exported to the evaluators but not exported within an <code id='code1590'
>export</code>
clause, the compiler will produce an error message. The <code id='code1591'
>library</code>
clause makes the variables and functions of a library accessible from
the interpreter.<br/><br/><center id='center1605'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1603'
>(<font color="#1919af"><strong id='bold31343'
>module</strong></font> <font color="#1919af"><strong id='bold31345'
>foo</strong></font>
   (<font color="#1919af"><strong id='bold31347'
>export</strong></font> (<font color="#1919af"><strong id='bold31349'
>fib</strong></font> x))
   (eval (<font color="#1919af"><strong id='bold31351'
>export</strong></font> <font color="#1919af"><strong id='bold31353'
>fib</strong></font>)
         (<font color="#1919af"><strong id='bold31355'
>import</strong></font> <font color="#1919af"><strong id='bold31357'
>bar</strong></font>)))<br/><br/>(<font color="#6959cf"><strong id='bold31359'
>define</strong></font> (<font color="#6959cf"><strong id='bold31361'
>fib</strong></font> x) ...)
(print bar)
</pre>
</td></tr>
</tbody></table></center>

The clause <code id='code1606'
>(class &lt;bind-name&gt;)</code> exports a class definition to
the interpreter. This makes the class constructor, the class predicate
and the slots access functions available from the interpreter. The
form 
   <code id='code1609'
>(instantiate::<code id='code1608'
><em id='it1607'
>class</em></code> ...)</code> 
and 
   <code id='code1612'
>(with-access::<code id='code1611'
><em id='it1610'
>class</em></code> ...)</code> 
are also available from the interpreter.
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1616" class="mark"></a><a name="extern" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1620" align="left" colspan="1"><strong id='bold1618'
>extern</strong><em id='it1619'
> extern ...</em></td><td id="tc1621" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

Extern (aka foreign) clauses will be explained in the foreign interface
(see <a href="bigloo-28.html#C-Interface" class="inbound">C Interface</a>).
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1627" class="mark"></a><a name="java" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1631" align="left" colspan="1"><strong id='bold1629'
>java</strong><em id='it1630'
> java ...</em></td><td id="tc1632" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

Java clauses will be explained in the Java interface
(see <a href="bigloo-29.html#Java-Interface" class="inbound">Java Interface</a>).
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1638" class="mark"></a><a name="option" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1642" align="left" colspan="1"><strong id='bold1640'
>option</strong><em id='it1641'
> option ...</em></td><td id="tc1643" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

This clause enables variables which affect compilation to be set from inside
a module and since the expressions, <code id='code1647'
><em id='it1646'
>option</em></code> ..., are evaluated
<em id='emph1648'
>when compiling</em>, no code is compiled for them.  They are allowed to
make side effects and to change the values of the global variables which
describe how the compiler must compile. Usually they allow the control
variables, which are described when Bigloo is invoked with the <code id='code1649'
>-help2</code>
option, to be set as in the following example:<br/><br/><center id='center1658'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1656'
>(<font color="#1919af"><strong id='bold31363'
>module</strong></font> <font color="#1919af"><strong id='bold31365'
>examplar</strong></font>
   (option (<strong id='bold31367'
>set!</strong> *debug* 3)
           (<strong id='bold31368'
>set!</strong> *verbose* 2)))<br/><br/>(print 'dummy)
</pre>
</td></tr>
</tbody></table></center>

Whatever arguments are passed on the command line, Bigloo will compile this
module in both verbose mode and debug mode.
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1662" class="mark"></a><a name="library" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1666" align="left" colspan="1"><strong id='bold1664'
>library</strong><em id='it1665'
> library ...</em></td><td id="tc1667" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>

This clause enables libraries (see <a href="bigloo-30.html#Bigloo-Libraries" class="inbound">Bigloo Libraries</a>) when compiling and
linking Bigloo modules. The expressions <code id='code1671'
><em id='it1670'
>library</em></code> ... are symbols
naming the libraries to be used.<br/><br/>Here is an example of a module declaration which makes use of a library
named <code id='code1673'
>format</code>:<br/><br/><center id='center1684'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1682'
>(<font color="#1919af"><strong id='bold31369'
>module</strong></font> <font color="#1919af"><strong id='bold31371'
>test</strong></font>
   (<font color="#1919af"><strong id='bold31373'
>library</strong></font> <font color="#1919af"><strong id='bold31375'
>format</strong></font>)
   (main    test-format)
   (<font color="#1919af"><strong id='bold31377'
>import</strong></font>  (<font color="#1919af"><strong id='bold31379'
>test2</strong></font> <font color="red">&quot;test2.scm&quot;</font>)))
</pre>
</td></tr>
</tbody></table></center>

Using a library does not automatically binds its variables and functions
to the interpreter. In order to make these available to the interpreter
an explicit use of an eval <code id='code1685'
>library</code> clause must be used.
</td></tr>
</tbody></table><br/>
<table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1689" class="mark"></a><a name="type" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1693" align="left" colspan="1"><strong id='bold1691'
>type</strong><em id='it1692'
> type ...</em></td><td id="tc1694" align="right" colspan="1">bigloo module clause</td></tr>
</tbody></table>
This forms is used to define builtin Bigloo types. It is not recommended
to use it in user programs. So, it is left undocumented.
</td></tr>
</tbody></table><br/><br/><br/></div><br>
<!-- Module initialization -->
<a name="Module-initialization"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.3 Module initialization</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Module-Initialization" class="mark"></a>
<em id='emph1700'
>Initializing</em> a module means evaluating, at runtime, its
top level forms (global bindings are top level forms).<br/><br/>When a module, <code id='code1703'
><em id='it1702'
>module1</em></code>, imports a module, <code id='code1705'
><em id='it1704'
>module2</em></code>,
<code id='code1707'
><em id='it1706'
>module2</em></code> is initialized before <code id='code1709'
><em id='it1708'
>module1</em></code>. Modules are
initialized only once, nothing being done if a module already met during 
initialization is met again. Library modules are initialized before user
modules and imported modules are initialized in the same order as they
appear in import clauses.<br/><br/>Here is a first example with two modules. First the module <code id='code1711'
>foo</code>:<br/><br/><center id='center1724'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1722'
><font color="#ffa600"><em id='it31382'
>;; module foo</em></font>
(<font color="#1919af"><strong id='bold31384'
>module</strong></font> <font color="#1919af"><strong id='bold31386'
>foo</strong></font>
   (main main)
   (<font color="#1919af"><strong id='bold31388'
>import</strong></font> (<font color="#1919af"><strong id='bold31390'
>bar</strong></font> <font color="red">&quot;bar.scm&quot;</font>)))<br/><br/>(<font color="#6959cf"><strong id='bold31393'
>define</strong></font> (<font color="#6959cf"><strong id='bold31395'
>main</strong></font> argv)
   (print <font color="red">&quot;argv: &quot;</font> argv))
(print <font color="red">&quot;foo&quot;</font>)
</pre>
</td></tr>
</tbody></table></center>

Then the module <code id='code1725'
>bar</code>
<center id='center1732'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1730'
><font color="#ffa600"><em id='it31399'
>;; module bar</em></font>
(<font color="#1919af"><strong id='bold31401'
>module</strong></font> <font color="#1919af"><strong id='bold31403'
>bar</strong></font>)<br/><br/>(print <font color="red">&quot;bar&quot;</font>)
</pre>
</td></tr>
</tbody></table></center>

These can be compiled into the executable <code id='code1734'
><em id='it1733'
>a.out</em></code> with:
<center id='center1737'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1735'
>$ bigloo -c foo.scm
$ bigloo -c bar.scm
$ bigloo foo.o bar.o
</pre>
</td></tr>
</tbody></table></center>

Execution of <code id='code1739'
><em id='it1738'
>a.out</em></code> produces:
<center id='center1742'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1740'
>$ a.out
   -| bar
      foo
      argv: (a.out)
</pre>
</td></tr>
</tbody></table></center>

The explanation is:
<ul class="itemize" id='itemize1757'
><li>module <code id='code1743'
>foo</code> contains the program entry point so this is where
 initialization begins.
</li>
<li>because <code id='code1745'
>foo</code> imports module <code id='code1746'
>bar</code>, <code id='code1747'
>bar</code> must be
 initialized <em id='emph1748'
>before</em> <code id='code1749'
>foo</code>. This explains why the word <code id='code1750'
>bar</code>
 is printed before anything else.
</li>
<li>module initialization for <code id='code1752'
>foo</code> is completed before <code id='code1753'
>main</code>
 is called. This explains why word <code id='code1754'
>foo</code> is printed before <code id='code1755'
>main</code>
 is entered.
</li>
</ul>
Let's consider another example with 3 modules:
<center id='center1771'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1769'
><font color="#ffa600"><em id='it31406'
>;; </em></font><code id='code1758'
>module1</code>
(<font color="#1919af"><strong id='bold31408'
>module</strong></font> <font color="#1919af"><strong id='bold31410'
>module1</strong></font>
   (main main)
   (<font color="#1919af"><strong id='bold31412'
>import</strong></font> (<font color="#1919af"><strong id='bold31414'
>module2</strong></font> <font color="red">&quot;module2.scm&quot;</font>)))<br/><br/>(<font color="#6959cf"><strong id='bold31417'
>define</strong></font> (<font color="#6959cf"><strong id='bold31419'
>main</strong></font> argv)
   (print <font color="red">&quot;argv: &quot;</font> argv))<br/><br/>(print <font color="red">&quot;module1&quot;</font>)
</pre>
</td></tr>
</tbody></table></center>

The second module:
<center id='center1782'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1780'
><font color="#ffa600"><em id='it31423'
>;; </em></font><code id='code1772'
>module2</code>
(<font color="#1919af"><strong id='bold31425'
>module</strong></font> <font color="#1919af"><strong id='bold31427'
>module2</strong></font>
   (<font color="#1919af"><strong id='bold31429'
>import</strong></font> (<font color="#1919af"><strong id='bold31431'
>module3</strong></font> <font color="red">&quot;module3.scm&quot;</font>)))<br/><br/>(print <font color="red">&quot;module2&quot;</font>)
</pre>
</td></tr>
</tbody></table></center>

The third module:
<center id='center1792'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1790'
><font color="#ffa600"><em id='it31435'
>;; </em></font><code id='code1783'
>module3</code>
(<font color="#1919af"><strong id='bold31437'
>module</strong></font> <font color="#1919af"><strong id='bold31439'
>module3</strong></font>
   (<font color="#1919af"><strong id='bold31441'
>import</strong></font> (<font color="#1919af"><strong id='bold31443'
>module1</strong></font> <font color="red">&quot;module1.scm&quot;</font>)))
 
(print <font color="red">&quot;module3&quot;</font>)
</pre>
</td></tr>
</tbody></table></center>

Compile with:
<center id='center1795'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1793'
>$ bigloo module1.scm -c
$ bigloo module2.scm -c
$ bigloo module3.scm -c
$ bigloo module1.o module2.o module3.o
</pre>
</td></tr>
</tbody></table></center>

Execution produces:<br/><br/><center id='center1799'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1797'
>$ a.out
   -| module3
      module2
      module1
      argv: (a.out)
</pre>
</td></tr>
</tbody></table></center>

The order of module initialization can be explicitly specified using <code id='code1800'
>with</code>
and <code id='code1801'
>use</code> clauses.
   
</div><br>
<!-- Qualified notation -->
<a name="Qualified-notation"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.4 Qualified notation</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Qualified-Notation" class="mark"></a><a name="g1802" class="mark"></a><a name="g1804" class="mark"></a>
Global variables can be referenced using implicit notation or
using <em id='emph1806'
>qualified</em> notation. Implicit notation is used when
variables are referenced just by their name whereas qualified notation
is used when variables are referenced by their name and 
the name of the module which defines them. Qualified notation has
the following syntax:<br/><br/><center id='center1810'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ccccff"><pre class="prog" id='prog1808'
>(&#x40; &lt;bind-name&gt; &lt;module-name&gt;)
</pre>
</td></tr>
</tbody></table></center>

and is useful when several imported modules export a
variable with the same name. Using qualified notations instead of
short notation only affects compilation.<br/><br/>When several variables are defined under the same identifier, the
compiler uses the two following rules in order to decide which
variable is selected by an implicit reference: 1) the variable defined
in a module has a higher precedence than all imported variables, 2)
imported variables have a higher precedence than library variables.<br/><br/></div><br>
<!-- Inline procedures -->
<a name="Inline-procedures"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.5 Inline procedures</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Inline-Procedures" class="mark"></a><a name="g1813" class="mark"></a>
Bigloo allows procedures called <em id='emph1815'
>inline</em> and which differ from
normal ones only in the type of code planted.  An inline procedure is a
first class object which can be manipulated in the same way as any other
procedure but when Bigloo sees a reference to one, rather than
generating a C function call to the function, the body of the inline
procedure is open-coded.  The definition of an inline is given in the
following way:<br/><br/><table cellspacing="0" class="frame" cellpadding="10" border="1" width="100%"><tbody>
<tr><td><a name="g1818" class="mark"></a><a name="define-inline" class="mark"></a><table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1822" align="left" colspan="1"><strong id='bold1820'
>define-inline</strong><em id='it1821'
> (name args ...) body</em></td><td id="tc1823" align="right" colspan="1">bigloo syntax</td></tr>
</tbody></table>
<table width="100%" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td id="tc1828" align="left" colspan="1"><strong id='bold1826'
>define-inline</strong><em id='it1827'
> (name args ... . arg) body</em></td><td id="tc1829" align="right" colspan="1">bigloo syntax</td></tr>
</tbody></table>

Apart from the initial word, this form has the same syntax as that used by
<code id='code1832'
>define</code> for procedures. Inline procedures are exportable which means
that the compiler scans imported files to find the bodies of all inline
procedures. Here is a small example of a module which exports an inline and
a module which imports it.<br/><br/><center id='center1843'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1841'
><font color="#ffa600"><em id='it31447'
>;; the exporter module</em></font>
(<font color="#1919af"><strong id='bold31449'
>module</strong></font> <font color="#1919af"><strong id='bold31451'
>exporter</strong></font>
        (<font color="#1919af"><strong id='bold31453'
>export</strong></font> (<strong id='bold31455'
>inline</strong> <font color="#1919af"><strong id='bold31456'
>make-list</strong></font> . objs)))<br/><br/>(<font color="#6959cf"><strong id='bold31458'
>define-inline</strong></font> (<font color="#6959cf"><strong id='bold31460'
>make-list</strong></font> . objs) objs)
</pre>
</td></tr>
</tbody></table></center>

<center id='center1851'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1849'
><font color="#ffa600"><em id='it31462'
>;; the importer module</em></font>
(<font color="#1919af"><strong id='bold31464'
>module</strong></font> <font color="#1919af"><strong id='bold31466'
>importer</strong></font>
        (<font color="#1919af"><strong id='bold31468'
>import</strong></font> <font color="#1919af"><strong id='bold31470'
>exporter</strong></font>))<br/><br/>(print (make-list 1 2 3 4 5))
</pre>
</td></tr>
</tbody></table></center>

Because of the open-coding of the exporter procedure, the above print
statement is equivalent to:<br/><br/><center id='center1856'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1854'
>(print (<strong id='bold31472'
>let</strong> ((objs (list 1 2 3 4 5)))
          objs))
</pre>
</td></tr>
</tbody></table></center>

Any procedure can be an inline. Also any exported procedure can be an inline
provided all global variables and functions it uses are also exported.<br/><br/>Note: Bigloo can decide to inline procedures declared with
<code id='code1858'
>define</code>
but this can be achieved only with local procedures whereas procedures
declared with the <code id='code1859'
>define-inline</code> form are open-coded even through
module importation.<br/><br/>Note: Procedures declared <em id='emph1861'
>inline</em> are macro expanded with 
the macro defined in the module where they are invoked. That is, if 
module <code id='code1862'
>module1</code> declares an inline procedure <code id='code1863'
>p</code> and module 
<code id='code1864'
>module2</code> imports it, <code id='code1865'
>p</code> may have two different macro-expansions: 
one for <code id='code1866'
>module1</code> and one for <code id='code1867'
>module2</code>.
</td></tr>
</tbody></table><br/>
</div><br>
<!-- Module access file -->
<a name="Module-access-file"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.6 Module access file</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Module-Access-File" class="mark"></a><a name="g1870" class="mark"></a><a name="g1872" class="mark"></a><a name="g1874" class="mark"></a><a name="g1876" class="mark"></a>
Bigloo is different from languages such as C where a module is defined by a
file. For Bigloo, the module name is not necessarily the name of the file
where the text of the module is written and modules can even be split across
several files.<br/><br/>Since modules are defined independently of files, it is necessary to make a
link between a module and its files and there are two ways of doing this.
Choosing an import clause where the file-names are specified or creating a
``module access file''. Such a file must contain only one <code id='code1880'
><em id='it1879'
>list</em></code>, each
element of the list being of the form:<br/><br/><center id='center1886'
><table cellspacing="0" class="color" cellpadding="0" width="95%"><tbody>
<tr><td bgcolor="#ffffcc"><pre class="prog" id='prog1884'
>(module-name <font color="red">&quot;file-name&quot;</font> ... <font color="red">&quot;file-name&quot;</font>)
</pre>
</td></tr>
</tbody></table></center>

Use the <samp id='samp1887'
>-afile &lt;file&gt;</samp> option to specify the ``module accessfile'' when compiling. By default Bigloo checks if a file named <code id='code1888'
>.afile</code>
exists. If it exists it is loaded as a module access file.<br/><br/>See <a href="bigloo-33.html#Compiler-Description" class="inbound">The Bigloo command line</a>.<br/><br/>Note: The Bigloo distribution contains a tool, <code id='code1891'
>bglafile</code>,
that can automatically build a ``module access file''. See the manpage for
<code id='code1892'
>bglafile</code> for details.<br/><br/></div><br>
<!-- Reading path -->
<a name="Reading-path"></a>
<div class="section-atitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">3.7 Reading path</font>
</h3></td></tr></table>
</div><div class="section">
<a name="Reading-Path" class="mark"></a><a name="g1894" class="mark"></a>
Imported, included or loaded files are sought first in the current directory
and then in the directories, sequentially from start to end, of the list in
the <code id='code1896'
>*load-path*</code>
<a name="g1897" class="mark"></a>variable. This variable,
initially set to the empty list, can be reset by the <samp id='samp1899'
>-I</samp> option of the
compiler.


</div><br>
</div></td>
</tr></table><div class="skribe-ending">
<hr> 
<p class="ending" id='paragraph31480'
><font size="-1">
This <span class="sc">Html</span> page has been produced by 
<a href="http://www-sop.inria.fr/indes/fp/Skribe" class="http">Skribe</a>.
<br/>
Last update <em id='it31478'
>Thu Nov 19 07:13:49 2020</em>.</font></p></div>
</body>
</html>